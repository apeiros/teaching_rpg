
[1mFrom:[0m /var/lib/gems/1.9.1/gems/pry-0.9.10/lib/pry/core_extensions.rb @ line 1:
[1mNumber of lines:[0m 89

[1;31mclass[0m [1;35mObject[0m
  [0;34m# Start a Pry REPL on self.[0m
  [0;34m#[0m
  [0;34m# If `self` is a Binding then that will be used to evaluate expressions;[0m
  [0;34m# otherwise a new binding will be created.[0m
  [0;34m#[0m
  [0;34m# @param [Object] object  the object or binding to pry[0m
  [0;34m#                         (__deprecated__, use `object.pry`)[0m
  [0;34m# @param [Hash] hash  the options hash[0m
  [0;34m# @example With a binding[0m
  [0;34m#    binding.pry[0m
  [0;34m# @example On any object[0m
  [0;34m#   "dummy".pry[0m
  [0;34m# @example With options[0m
  [0;34m#   def my_method[0m
  [0;34m#     binding.pry :quiet => true[0m
  [0;34m#   end[0m
  [0;34m#   my_method()[0m
  [0;34m# @see Pry.start[0m
  [1;31mdef[0m [1;34mpry[0m(object=[1;36mnil[0m, hash={})
    [1;31mif[0m object.nil? || [1;34m[4mHash[0m === object
      [1;34m[4mPry[0m.start([1;36mself[0m, object || {})
    [1;31melse[0m
      [1;34m[4mPry[0m.start(object, hash)
    [1;31mend[0m
  [1;31mend[0m

  [0;34m# Return a binding object for the receiver.[0m
  [0;34m#[0m
  [0;34m# The `self` of the binding is set to the current object, and it contains no[0m
  [0;34m# local variables.[0m
  [0;34m#[0m
  [0;34m# The default definee (http://yugui.jp/articles/846) is set such that:[0m
  [0;34m#[0m
  [0;34m# * If `self` is a class or module, then new methods created in the binding[0m
  [0;34m#   will be defined in that class or module (as in `class Foo; end`).[0m
  [0;34m# * If `self` is a normal object, then new methods created in the binding will[0m
  [0;34m#   be defined on its singleton class (as in `class << self; end`).[0m
  [0;34m# * If `self` doesn't have a  real singleton class (i.e. it is a Fixnum, Float,[0m
  [0;34m#   Symbol, nil, true, or false), then new methods will be created on the[0m
  [0;34m#   object's class (as in `self.class.class_eval{ }`)[0m
  [0;34m#[0m
  [0;34m# Newly created constants, including classes and modules, will also be added[0m
  [0;34m# to the default definee.[0m
  [0;34m#[0m
  [0;34m# @return [Binding][0m
  [1;31mdef[0m [1;34m__binding__[0m
    [0;34m# When you're cd'd into a class, methods you define should be added to it.[0m
    [1;31mif[0m is_a?([1;34m[4mModule[0m)
      [0;34m# class_eval sets both self and the default definee to this class.[0m
      [1;31mreturn[0m class_eval [32m[1;32m"[0m[32mbinding[1;32m"[0m[32m[0m
    [1;31mend[0m

    [1;31munless[0m respond_to?([1;32m:__pry__[0m)
      binding_impl_method = [[32m[1;32m<<-METHOD[0m[32m[0m, [1;36m__FILE__[0m, [1;36m__LINE__[0m + [1;34m1[0m]
        [0;34m# Get a binding with 'self' set to self, and no locals.[0m
        [0;34m#[0m
        [0;34m# The default definee is determined by the context in which the[0m
        [0;34m# definition is eval'd.[0m
        [0;34m#[0m
        [0;34m# Please don't call this method directly, see {__binding__}.[0m
        [0;34m#[0m
        [0;34m# @return [Binding][0m
        [1;31mdef[0m [1;34m__pry__[0m
          binding
        [1;31mend[0m
      [1;34m[4mMETHOD[0m

      [0;34m# The easiest way to check whether an object has a working singleton class[0m
      [0;34m# is to try and define a method on it. (just checking for the presence of[0m
      [0;34m# the singleton class gives false positives for `true` and `false`).[0m
      [0;34m# __pry__ is just the closest method we have to hand, and using[0m
      [0;34m# it has the nice property that we can memoize this check.[0m
      [1;31mbegin[0m
        [0;34m# instance_eval sets the default definee to the object's singleton class[0m
        instance_eval(*binding_impl_method)

      [0;34m# If we can't define methods on the Object's singleton_class. Then we fall[0m
      [0;34m# back to setting the default definee to be the Object's class. That seems[0m
      [0;34m# nicer than having a REPL in which you can't define methods.[0m
      [1;31mrescue[0m [1;34m[4mTypeError[0m
        [0;34m# class_eval sets the default definee to self.class[0m
        [1;36mself[0m.class.class_eval(*binding_impl_method)
      [1;31mend[0m
    [1;31mend[0m

    __pry__
  [1;31mend[0m
[1;31mend[0m
